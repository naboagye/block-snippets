{"ast":null,"code":"'use strict';\n\nmodule.exports = factory; // Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.\n\nfunction factory(type) {\n  return tokenize; // Tokenizer for a bound `type`.\n\n  function tokenize(value, location) {\n    var self = this;\n    var offset = self.offset;\n    var tokens = [];\n    var methods = self[type + 'Methods'];\n    var tokenizers = self[type + 'Tokenizers'];\n    var line = location.line;\n    var column = location.column;\n    var index;\n    var length;\n    var method;\n    var name;\n    var matched;\n    var valueLength; // Trim white space only lines.\n\n    if (!value) {\n      return tokens;\n    } // Expose on `eat`.\n\n\n    eat.now = now;\n    eat.file = self.file; // Sync initial offset.\n\n    updatePosition(''); // Iterate over `value`, and iterate over all tokenizers.  When one eats\n    // something, re-iterate with the remaining value.  If no tokenizer eats,\n    // something failed (should not happen) and an exception is thrown.\n\n    while (value) {\n      index = -1;\n      length = methods.length;\n      matched = false;\n\n      while (++index < length) {\n        name = methods[index];\n        method = tokenizers[name]; // Previously, we had constructs such as footnotes and YAML that used\n        // these properties.\n        // Those are now external (plus there are userland extensions), that may\n        // still use them.\n\n        if (method && (\n        /* istanbul ignore next */\n        !method.onlyAtStart || self.atStart) && (\n        /* istanbul ignore next */\n        !method.notInList || !self.inList) && (\n        /* istanbul ignore next */\n        !method.notInBlock || !self.inBlock) && (!method.notInLink || !self.inLink)) {\n          valueLength = value.length;\n          method.apply(self, [eat, value]);\n          matched = valueLength !== value.length;\n\n          if (matched) {\n            break;\n          }\n        }\n      }\n      /* istanbul ignore if */\n\n\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now());\n      }\n    }\n\n    self.eof = now();\n    return tokens; // Update line, column, and offset based on `value`.\n\n    function updatePosition(subvalue) {\n      var lastIndex = -1;\n      var index = subvalue.indexOf('\\n');\n\n      while (index !== -1) {\n        line++;\n        lastIndex = index;\n        index = subvalue.indexOf('\\n', index + 1);\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length;\n      } else {\n        column = subvalue.length - lastIndex;\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line];\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1;\n        }\n      }\n    } // Get offset.  Called before the first character is eaten to retrieve the\n    // range’s offsets.\n\n\n    function getOffset() {\n      var indentation = [];\n      var pos = line + 1; // Done.  Called when the last character is eaten to retrieve the range’s\n      // offsets.\n\n      return function () {\n        var last = line + 1;\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1);\n          pos++;\n        }\n\n        return indentation;\n      };\n    } // Get the current position.\n\n\n    function now() {\n      var pos = {\n        line: line,\n        column: column\n      };\n      pos.offset = self.toOffset(pos);\n      return pos;\n    } // Store position information for a node.\n\n\n    function Position(start) {\n      this.start = start;\n      this.end = now();\n    } // Throw when a value is incorrectly eaten.  This shouldn’t happen but will\n    // throw on new, incorrect rules.\n\n\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.slice(0, subvalue.length) !== subvalue) {\n        // Capture stack-trace.\n        self.file.fail(new Error('Incorrectly eaten value: please report this warning on https://git.io/vg5Ft'), now());\n      }\n    } // Mark position and patch `node.position`.\n\n\n    function position() {\n      var before = now();\n      return update; // Add the position to a node.\n\n      function update(node, indent) {\n        var previous = node.position;\n        var start = previous ? previous.start : before;\n        var combined = [];\n        var n = previous && previous.end.line;\n        var l = before.line;\n        node.position = new Position(start); // If there was already a `position`, this node was merged.  Fixing\n        // `start` wasn’t hard, but the indent is different.  Especially\n        // because some information, the indent between `n` and `l` wasn’t\n        // tracked.  Luckily, that space is (should be?) empty, so we can\n        // safely check for it now.\n\n        if (previous && indent && previous.indent) {\n          combined = previous.indent;\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1);\n            }\n\n            combined.push(before.column);\n          }\n\n          indent = combined.concat(indent);\n        }\n\n        node.position.indent = indent || [];\n        return node;\n      }\n    } // Add `node` to `parent`s children or to `tokens`.  Performs merges where\n    // possible.\n\n\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens;\n      var previous = children[children.length - 1];\n      var fn;\n\n      if (previous && node.type === previous.type && (node.type === 'text' || node.type === 'blockquote') && mergeable(previous) && mergeable(node)) {\n        fn = node.type === 'text' ? mergeText : mergeBlockquote;\n        node = fn.call(self, previous, node);\n      }\n\n      if (node !== previous) {\n        children.push(node);\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart();\n      }\n\n      return node;\n    } // Remove `subvalue` from `value`.  `subvalue` must be at the start of\n    // `value`.\n\n\n    function eat(subvalue) {\n      var indent = getOffset();\n      var pos = position();\n      var current = now();\n      validateEat(subvalue);\n      apply.reset = reset;\n      reset.test = test;\n      apply.test = test;\n      value = value.slice(subvalue.length);\n      updatePosition(subvalue);\n      indent = indent();\n      return apply; // Add the given arguments, add `position` to the returned node, and\n      // return the node.\n\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent);\n      } // Functions just like apply, but resets the content: the line and\n      // column are reversed, and the eaten value is re-added.   This is\n      // useful for nodes with a single type of content, such as lists and\n      // tables.  See `apply` above for what parameters are expected.\n\n\n      function reset() {\n        var node = apply.apply(null, arguments);\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return node;\n      } // Test the position, after eating, and reverse to a not-eaten state.\n\n\n      function test() {\n        var result = pos({});\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return result.position;\n      }\n    }\n  }\n} // Check whether a node is mergeable with adjacent nodes.\n\n\nfunction mergeable(node) {\n  var start;\n  var end;\n\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n\n  start = node.position.start;\n  end = node.position.end; // Only merge nodes which occupy the same size as their `value`.\n\n  return start.line !== end.line || end.column - start.column === node.value.length;\n} // Merge two text nodes: `node` into `prev`.\n\n\nfunction mergeText(previous, node) {\n  previous.value += node.value;\n  return previous;\n} // Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.\n\n\nfunction mergeBlockquote(previous, node) {\n  if (this.options.commonmark || this.options.gfm) {\n    return node;\n  }\n\n  previous.children = previous.children.concat(node.children);\n  return previous;\n}","map":{"version":3,"names":["module","exports","factory","type","tokenize","value","location","self","offset","tokens","methods","tokenizers","line","column","index","length","method","name","matched","valueLength","eat","now","file","updatePosition","onlyAtStart","atStart","notInList","inList","notInBlock","inBlock","notInLink","inLink","apply","fail","Error","eof","subvalue","lastIndex","indexOf","getOffset","indentation","pos","last","push","toOffset","Position","start","end","validateEat","slice","position","before","update","node","indent","previous","combined","n","l","concat","add","parent","children","fn","mergeable","mergeText","mergeBlockquote","call","exitStart","current","reset","test","arguments","result","options","commonmark","gfm"],"sources":["/Users/The5AMDev/web3/gif-portal-starter/node_modules/remark-parse/lib/tokenizer.js"],"sourcesContent":["'use strict'\n\nmodule.exports = factory\n\n// Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.\nfunction factory(type) {\n  return tokenize\n\n  // Tokenizer for a bound `type`.\n  function tokenize(value, location) {\n    var self = this\n    var offset = self.offset\n    var tokens = []\n    var methods = self[type + 'Methods']\n    var tokenizers = self[type + 'Tokenizers']\n    var line = location.line\n    var column = location.column\n    var index\n    var length\n    var method\n    var name\n    var matched\n    var valueLength\n\n    // Trim white space only lines.\n    if (!value) {\n      return tokens\n    }\n\n    // Expose on `eat`.\n    eat.now = now\n    eat.file = self.file\n\n    // Sync initial offset.\n    updatePosition('')\n\n    // Iterate over `value`, and iterate over all tokenizers.  When one eats\n    // something, re-iterate with the remaining value.  If no tokenizer eats,\n    // something failed (should not happen) and an exception is thrown.\n    while (value) {\n      index = -1\n      length = methods.length\n      matched = false\n\n      while (++index < length) {\n        name = methods[index]\n        method = tokenizers[name]\n\n        // Previously, we had constructs such as footnotes and YAML that used\n        // these properties.\n        // Those are now external (plus there are userland extensions), that may\n        // still use them.\n        if (\n          method &&\n          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&\n          /* istanbul ignore next */ (!method.notInList || !self.inList) &&\n          /* istanbul ignore next */ (!method.notInBlock || !self.inBlock) &&\n          (!method.notInLink || !self.inLink)\n        ) {\n          valueLength = value.length\n\n          method.apply(self, [eat, value])\n\n          matched = valueLength !== value.length\n\n          if (matched) {\n            break\n          }\n        }\n      }\n\n      /* istanbul ignore if */\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now())\n      }\n    }\n\n    self.eof = now()\n\n    return tokens\n\n    // Update line, column, and offset based on `value`.\n    function updatePosition(subvalue) {\n      var lastIndex = -1\n      var index = subvalue.indexOf('\\n')\n\n      while (index !== -1) {\n        line++\n        lastIndex = index\n        index = subvalue.indexOf('\\n', index + 1)\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length\n      } else {\n        column = subvalue.length - lastIndex\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line]\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1\n        }\n      }\n    }\n\n    // Get offset.  Called before the first character is eaten to retrieve the\n    // range’s offsets.\n    function getOffset() {\n      var indentation = []\n      var pos = line + 1\n\n      // Done.  Called when the last character is eaten to retrieve the range’s\n      // offsets.\n      return function () {\n        var last = line + 1\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1)\n\n          pos++\n        }\n\n        return indentation\n      }\n    }\n\n    // Get the current position.\n    function now() {\n      var pos = {line: line, column: column}\n\n      pos.offset = self.toOffset(pos)\n\n      return pos\n    }\n\n    // Store position information for a node.\n    function Position(start) {\n      this.start = start\n      this.end = now()\n    }\n\n    // Throw when a value is incorrectly eaten.  This shouldn’t happen but will\n    // throw on new, incorrect rules.\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.slice(0, subvalue.length) !== subvalue) {\n        // Capture stack-trace.\n        self.file.fail(\n          new Error(\n            'Incorrectly eaten value: please report this warning on https://git.io/vg5Ft'\n          ),\n          now()\n        )\n      }\n    }\n\n    // Mark position and patch `node.position`.\n    function position() {\n      var before = now()\n\n      return update\n\n      // Add the position to a node.\n      function update(node, indent) {\n        var previous = node.position\n        var start = previous ? previous.start : before\n        var combined = []\n        var n = previous && previous.end.line\n        var l = before.line\n\n        node.position = new Position(start)\n\n        // If there was already a `position`, this node was merged.  Fixing\n        // `start` wasn’t hard, but the indent is different.  Especially\n        // because some information, the indent between `n` and `l` wasn’t\n        // tracked.  Luckily, that space is (should be?) empty, so we can\n        // safely check for it now.\n        if (previous && indent && previous.indent) {\n          combined = previous.indent\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1)\n            }\n\n            combined.push(before.column)\n          }\n\n          indent = combined.concat(indent)\n        }\n\n        node.position.indent = indent || []\n\n        return node\n      }\n    }\n\n    // Add `node` to `parent`s children or to `tokens`.  Performs merges where\n    // possible.\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens\n      var previous = children[children.length - 1]\n      var fn\n\n      if (\n        previous &&\n        node.type === previous.type &&\n        (node.type === 'text' || node.type === 'blockquote') &&\n        mergeable(previous) &&\n        mergeable(node)\n      ) {\n        fn = node.type === 'text' ? mergeText : mergeBlockquote\n        node = fn.call(self, previous, node)\n      }\n\n      if (node !== previous) {\n        children.push(node)\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart()\n      }\n\n      return node\n    }\n\n    // Remove `subvalue` from `value`.  `subvalue` must be at the start of\n    // `value`.\n    function eat(subvalue) {\n      var indent = getOffset()\n      var pos = position()\n      var current = now()\n\n      validateEat(subvalue)\n\n      apply.reset = reset\n      reset.test = test\n      apply.test = test\n\n      value = value.slice(subvalue.length)\n\n      updatePosition(subvalue)\n\n      indent = indent()\n\n      return apply\n\n      // Add the given arguments, add `position` to the returned node, and\n      // return the node.\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent)\n      }\n\n      // Functions just like apply, but resets the content: the line and\n      // column are reversed, and the eaten value is re-added.   This is\n      // useful for nodes with a single type of content, such as lists and\n      // tables.  See `apply` above for what parameters are expected.\n      function reset() {\n        var node = apply.apply(null, arguments)\n\n        line = current.line\n        column = current.column\n        value = subvalue + value\n\n        return node\n      }\n\n      // Test the position, after eating, and reverse to a not-eaten state.\n      function test() {\n        var result = pos({})\n\n        line = current.line\n        column = current.column\n        value = subvalue + value\n\n        return result.position\n      }\n    }\n  }\n}\n\n// Check whether a node is mergeable with adjacent nodes.\nfunction mergeable(node) {\n  var start\n  var end\n\n  if (node.type !== 'text' || !node.position) {\n    return true\n  }\n\n  start = node.position.start\n  end = node.position.end\n\n  // Only merge nodes which occupy the same size as their `value`.\n  return (\n    start.line !== end.line || end.column - start.column === node.value.length\n  )\n}\n\n// Merge two text nodes: `node` into `prev`.\nfunction mergeText(previous, node) {\n  previous.value += node.value\n\n  return previous\n}\n\n// Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.\nfunction mergeBlockquote(previous, node) {\n  if (this.options.commonmark || this.options.gfm) {\n    return node\n  }\n\n  previous.children = previous.children.concat(node.children)\n\n  return previous\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}