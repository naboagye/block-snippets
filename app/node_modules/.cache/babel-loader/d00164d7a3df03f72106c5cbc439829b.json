{"ast":null,"code":"'use strict';\n\nvar bail = require('bail');\n\nvar buffer = require('is-buffer');\n\nvar extend = require('extend');\n\nvar plain = require('is-plain-obj');\n\nvar trough = require('trough');\n\nvar vfile = require('vfile'); // Expose a frozen processor.\n\n\nmodule.exports = unified().freeze();\nvar slice = [].slice;\nvar own = {}.hasOwnProperty; // Process pipeline.\n\nvar pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);\n\nfunction pipelineParse(p, ctx) {\n  ctx.tree = p.parse(ctx.file);\n}\n\nfunction pipelineRun(p, ctx, next) {\n  p.run(ctx.tree, ctx.file, done);\n\n  function done(error, tree, file) {\n    if (error) {\n      next(error);\n    } else {\n      ctx.tree = tree;\n      ctx.file = file;\n      next();\n    }\n  }\n}\n\nfunction pipelineStringify(p, ctx) {\n  var result = p.stringify(ctx.tree, ctx.file);\n\n  if (result === undefined || result === null) {// Empty.\n  } else if (typeof result === 'string' || buffer(result)) {\n    if ('value' in ctx.file) {\n      ctx.file.value = result;\n    }\n\n    ctx.file.contents = result;\n  } else {\n    ctx.file.result = result;\n  }\n} // Function to create the first processor.\n\n\nfunction unified() {\n  var attachers = [];\n  var transformers = trough();\n  var namespace = {};\n  var freezeIndex = -1;\n  var frozen; // Data management.\n\n  processor.data = data; // Lock.\n\n  processor.freeze = freeze; // Plugins.\n\n  processor.attachers = attachers;\n  processor.use = use; // API.\n\n  processor.parse = parse;\n  processor.stringify = stringify;\n  processor.run = run;\n  processor.runSync = runSync;\n  processor.process = process;\n  processor.processSync = processSync; // Expose.\n\n  return processor; // Create a new processor based on the processor in the current scope.\n\n  function processor() {\n    var destination = unified();\n    var index = -1;\n\n    while (++index < attachers.length) {\n      destination.use.apply(null, attachers[index]);\n    }\n\n    destination.data(extend(true, {}, namespace));\n    return destination;\n  } // Freeze: used to signal a processor that has finished configuration.\n  //\n  // For example, take unified itself: it’s frozen.\n  // Plugins should not be added to it.\n  // Rather, it should be extended, by invoking it, before modifying it.\n  //\n  // In essence, always invoke this when exporting a processor.\n\n\n  function freeze() {\n    var values;\n    var transformer;\n\n    if (frozen) {\n      return processor;\n    }\n\n    while (++freezeIndex < attachers.length) {\n      values = attachers[freezeIndex];\n\n      if (values[1] === false) {\n        continue;\n      }\n\n      if (values[1] === true) {\n        values[1] = undefined;\n      }\n\n      transformer = values[0].apply(processor, values.slice(1));\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer);\n      }\n    }\n\n    frozen = true;\n    freezeIndex = Infinity;\n    return processor;\n  } // Data management.\n  // Getter / setter for processor-specific informtion.\n\n\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen);\n        namespace[key] = value;\n        return processor;\n      } // Get `key`.\n\n\n      return own.call(namespace, key) && namespace[key] || null;\n    } // Set space.\n\n\n    if (key) {\n      assertUnfrozen('data', frozen);\n      namespace = key;\n      return processor;\n    } // Get space.\n\n\n    return namespace;\n  } // Plugin management.\n  //\n  // Pass it:\n  // *   an attacher and options,\n  // *   a preset,\n  // *   a list of presets, attachers, and arguments (list of attachers and\n  //     options).\n\n\n  function use(value) {\n    var settings;\n    assertUnfrozen('use', frozen);\n\n    if (value === null || value === undefined) {// Empty.\n    } else if (typeof value === 'function') {\n      addPlugin.apply(null, arguments);\n    } else if (typeof value === 'object') {\n      if ('length' in value) {\n        addList(value);\n      } else {\n        addPreset(value);\n      }\n    } else {\n      throw new Error('Expected usable value, not `' + value + '`');\n    }\n\n    if (settings) {\n      namespace.settings = extend(namespace.settings || {}, settings);\n    }\n\n    return processor;\n\n    function addPreset(result) {\n      addList(result.plugins);\n\n      if (result.settings) {\n        settings = extend(settings || {}, result.settings);\n      }\n    }\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value);\n      } else if (typeof value === 'object') {\n        if ('length' in value) {\n          addPlugin.apply(null, value);\n        } else {\n          addPreset(value);\n        }\n      } else {\n        throw new Error('Expected usable value, not `' + value + '`');\n      }\n    }\n\n    function addList(plugins) {\n      var index = -1;\n\n      if (plugins === null || plugins === undefined) {// Empty.\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\n        while (++index < plugins.length) {\n          add(plugins[index]);\n        }\n      } else {\n        throw new Error('Expected a list of plugins, not `' + plugins + '`');\n      }\n    }\n\n    function addPlugin(plugin, value) {\n      var entry = find(plugin);\n\n      if (entry) {\n        if (plain(entry[1]) && plain(value)) {\n          value = extend(true, entry[1], value);\n        }\n\n        entry[1] = value;\n      } else {\n        attachers.push(slice.call(arguments));\n      }\n    }\n  }\n\n  function find(plugin) {\n    var index = -1;\n\n    while (++index < attachers.length) {\n      if (attachers[index][0] === plugin) {\n        return attachers[index];\n      }\n    }\n  } // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor.\n\n\n  function parse(doc) {\n    var file = vfile(doc);\n    var Parser;\n    freeze();\n    Parser = processor.Parser;\n    assertParser('parse', Parser);\n\n    if (newable(Parser, 'parse')) {\n      return new Parser(String(file), file).parse();\n    }\n\n    return Parser(String(file), file); // eslint-disable-line new-cap\n  } // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), async.\n\n\n  function run(node, file, cb) {\n    assertNode(node);\n    freeze();\n\n    if (!cb && typeof file === 'function') {\n      cb = file;\n      file = null;\n    }\n\n    if (!cb) {\n      return new Promise(executor);\n    }\n\n    executor(null, cb);\n\n    function executor(resolve, reject) {\n      transformers.run(node, vfile(file), done);\n\n      function done(error, tree, file) {\n        tree = tree || node;\n\n        if (error) {\n          reject(error);\n        } else if (resolve) {\n          resolve(tree);\n        } else {\n          cb(null, tree, file);\n        }\n      }\n    }\n  } // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), sync.\n\n\n  function runSync(node, file) {\n    var result;\n    var complete;\n    run(node, file, done);\n    assertDone('runSync', 'run', complete);\n    return result;\n\n    function done(error, tree) {\n      complete = true;\n      result = tree;\n      bail(error);\n    }\n  } // Stringify a unist node representation of a file (in string or vfile\n  // representation) into a string using the `Compiler` on the processor.\n\n\n  function stringify(node, doc) {\n    var file = vfile(doc);\n    var Compiler;\n    freeze();\n    Compiler = processor.Compiler;\n    assertCompiler('stringify', Compiler);\n    assertNode(node);\n\n    if (newable(Compiler, 'compile')) {\n      return new Compiler(node, file).compile();\n    }\n\n    return Compiler(node, file); // eslint-disable-line new-cap\n  } // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor, then run transforms on that node, and\n  // compile the resulting node using the `Compiler` on the processor, and\n  // store that result on the vfile.\n\n\n  function process(doc, cb) {\n    freeze();\n    assertParser('process', processor.Parser);\n    assertCompiler('process', processor.Compiler);\n\n    if (!cb) {\n      return new Promise(executor);\n    }\n\n    executor(null, cb);\n\n    function executor(resolve, reject) {\n      var file = vfile(doc);\n      pipeline.run(processor, {\n        file: file\n      }, done);\n\n      function done(error) {\n        if (error) {\n          reject(error);\n        } else if (resolve) {\n          resolve(file);\n        } else {\n          cb(null, file);\n        }\n      }\n    }\n  } // Process the given document (in string or vfile representation), sync.\n\n\n  function processSync(doc) {\n    var file;\n    var complete;\n    freeze();\n    assertParser('processSync', processor.Parser);\n    assertCompiler('processSync', processor.Compiler);\n    file = vfile(doc);\n    process(file, done);\n    assertDone('processSync', 'process', complete);\n    return file;\n\n    function done(error) {\n      complete = true;\n      bail(error);\n    }\n  }\n} // Check if `value` is a constructor.\n\n\nfunction newable(value, name) {\n  return typeof value === 'function' && value.prototype && ( // A function with keys in its prototype is probably a constructor.\n  // Classes’ prototype methods are not enumerable, so we check if some value\n  // exists in the prototype.\n  keys(value.prototype) || name in value.prototype);\n} // Check if `value` is an object with keys.\n\n\nfunction keys(value) {\n  var key;\n\n  for (key in value) {\n    return true;\n  }\n\n  return false;\n} // Assert a parser is available.\n\n\nfunction assertParser(name, Parser) {\n  if (typeof Parser !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Parser`');\n  }\n} // Assert a compiler is available.\n\n\nfunction assertCompiler(name, Compiler) {\n  if (typeof Compiler !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Compiler`');\n  }\n} // Assert the processor is not frozen.\n\n\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error('Cannot invoke `' + name + '` on a frozen processor.\\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.');\n  }\n} // Assert `node` is a unist node.\n\n\nfunction assertNode(node) {\n  if (!node || typeof node.type !== 'string') {\n    throw new Error('Expected node, got `' + node + '`');\n  }\n} // Assert that `complete` is `true`.\n\n\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');\n  }\n}","map":{"version":3,"names":["bail","require","buffer","extend","plain","trough","vfile","module","exports","unified","freeze","slice","own","hasOwnProperty","pipeline","use","pipelineParse","pipelineRun","pipelineStringify","p","ctx","tree","parse","file","next","run","done","error","result","stringify","undefined","value","contents","attachers","transformers","namespace","freezeIndex","frozen","processor","data","runSync","process","processSync","destination","index","length","apply","values","transformer","Infinity","key","arguments","assertUnfrozen","call","settings","addPlugin","addList","addPreset","Error","plugins","add","plugin","entry","find","push","doc","Parser","assertParser","newable","String","node","cb","assertNode","Promise","executor","resolve","reject","complete","assertDone","Compiler","assertCompiler","compile","name","prototype","keys","type","asyncName"],"sources":["/Users/The5AMDev/web3/gif-portal-starter/node_modules/unified/index.js"],"sourcesContent":["'use strict'\n\nvar bail = require('bail')\nvar buffer = require('is-buffer')\nvar extend = require('extend')\nvar plain = require('is-plain-obj')\nvar trough = require('trough')\nvar vfile = require('vfile')\n\n// Expose a frozen processor.\nmodule.exports = unified().freeze()\n\nvar slice = [].slice\nvar own = {}.hasOwnProperty\n\n// Process pipeline.\nvar pipeline = trough()\n  .use(pipelineParse)\n  .use(pipelineRun)\n  .use(pipelineStringify)\n\nfunction pipelineParse(p, ctx) {\n  ctx.tree = p.parse(ctx.file)\n}\n\nfunction pipelineRun(p, ctx, next) {\n  p.run(ctx.tree, ctx.file, done)\n\n  function done(error, tree, file) {\n    if (error) {\n      next(error)\n    } else {\n      ctx.tree = tree\n      ctx.file = file\n      next()\n    }\n  }\n}\n\nfunction pipelineStringify(p, ctx) {\n  var result = p.stringify(ctx.tree, ctx.file)\n\n  if (result === undefined || result === null) {\n    // Empty.\n  } else if (typeof result === 'string' || buffer(result)) {\n    if ('value' in ctx.file) {\n      ctx.file.value = result\n    }\n\n    ctx.file.contents = result\n  } else {\n    ctx.file.result = result\n  }\n}\n\n// Function to create the first processor.\nfunction unified() {\n  var attachers = []\n  var transformers = trough()\n  var namespace = {}\n  var freezeIndex = -1\n  var frozen\n\n  // Data management.\n  processor.data = data\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  processor.run = run\n  processor.runSync = runSync\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  function processor() {\n    var destination = unified()\n    var index = -1\n\n    while (++index < attachers.length) {\n      destination.use.apply(null, attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  // Freeze: used to signal a processor that has finished configuration.\n  //\n  // For example, take unified itself: it’s frozen.\n  // Plugins should not be added to it.\n  // Rather, it should be extended, by invoking it, before modifying it.\n  //\n  // In essence, always invoke this when exporting a processor.\n  function freeze() {\n    var values\n    var transformer\n\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      values = attachers[freezeIndex]\n\n      if (values[1] === false) {\n        continue\n      }\n\n      if (values[1] === true) {\n        values[1] = undefined\n      }\n\n      transformer = values[0].apply(processor, values.slice(1))\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Infinity\n\n    return processor\n  }\n\n  // Data management.\n  // Getter / setter for processor-specific informtion.\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  // Plugin management.\n  //\n  // Pass it:\n  // *   an attacher and options,\n  // *   a preset,\n  // *   a list of presets, attachers, and arguments (list of attachers and\n  //     options).\n  function use(value) {\n    var settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin.apply(null, arguments)\n    } else if (typeof value === 'object') {\n      if ('length' in value) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new Error('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = extend(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = extend(settings || {}, result.settings)\n      }\n    }\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if ('length' in value) {\n          addPlugin.apply(null, value)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new Error('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    function addList(plugins) {\n      var index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\n        while (++index < plugins.length) {\n          add(plugins[index])\n        }\n      } else {\n        throw new Error('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    function addPlugin(plugin, value) {\n      var entry = find(plugin)\n\n      if (entry) {\n        if (plain(entry[1]) && plain(value)) {\n          value = extend(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        attachers.push(slice.call(arguments))\n      }\n    }\n  }\n\n  function find(plugin) {\n    var index = -1\n\n    while (++index < attachers.length) {\n      if (attachers[index][0] === plugin) {\n        return attachers[index]\n      }\n    }\n  }\n\n  // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor.\n  function parse(doc) {\n    var file = vfile(doc)\n    var Parser\n\n    freeze()\n    Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      return new Parser(String(file), file).parse()\n    }\n\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), async.\n  function run(node, file, cb) {\n    assertNode(node)\n    freeze()\n\n    if (!cb && typeof file === 'function') {\n      cb = file\n      file = null\n    }\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      transformers.run(node, vfile(file), done)\n\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          cb(null, tree, file)\n        }\n      }\n    }\n  }\n\n  // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), sync.\n  function runSync(node, file) {\n    var result\n    var complete\n\n    run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    return result\n\n    function done(error, tree) {\n      complete = true\n      result = tree\n      bail(error)\n    }\n  }\n\n  // Stringify a unist node representation of a file (in string or vfile\n  // representation) into a string using the `Compiler` on the processor.\n  function stringify(node, doc) {\n    var file = vfile(doc)\n    var Compiler\n\n    freeze()\n    Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      return new Compiler(node, file).compile()\n    }\n\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor, then run transforms on that node, and\n  // compile the resulting node using the `Compiler` on the processor, and\n  // store that result on the vfile.\n  function process(doc, cb) {\n    freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      var file = vfile(doc)\n\n      pipeline.run(processor, {file: file}, done)\n\n      function done(error) {\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          cb(null, file)\n        }\n      }\n    }\n  }\n\n  // Process the given document (in string or vfile representation), sync.\n  function processSync(doc) {\n    var file\n    var complete\n\n    freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n    file = vfile(doc)\n\n    process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    function done(error) {\n      complete = true\n      bail(error)\n    }\n  }\n}\n\n// Check if `value` is a constructor.\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes’ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n// Check if `value` is an object with keys.\nfunction keys(value) {\n  var key\n  for (key in value) {\n    return true\n  }\n\n  return false\n}\n\n// Assert a parser is available.\nfunction assertParser(name, Parser) {\n  if (typeof Parser !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n// Assert a compiler is available.\nfunction assertCompiler(name, Compiler) {\n  if (typeof Compiler !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n// Assert the processor is not frozen.\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot invoke `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n// Assert `node` is a unist node.\nfunction assertNode(node) {\n  if (!node || typeof node.type !== 'string') {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n}\n\n// Assert that `complete` is `true`.\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}