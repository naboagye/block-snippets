{"ast":null,"code":"export class SelectionText {\n  constructor(elm) {\n    this.elm = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.value = void 0;\n    var {\n      selectionStart,\n      selectionEnd\n    } = elm;\n    this.elm = elm;\n    this.start = selectionStart;\n    this.end = selectionEnd;\n    this.value = this.elm.value;\n  }\n\n  position(start, end) {\n    var {\n      selectionStart,\n      selectionEnd\n    } = this.elm;\n    this.start = typeof start === 'number' && !isNaN(start) ? start : selectionStart;\n    this.end = typeof end === 'number' && !isNaN(end) ? end : selectionEnd;\n    this.elm.selectionStart = this.start;\n    this.elm.selectionEnd = this.end;\n    return this;\n  }\n\n  insertText(text) {\n    // Most of the used APIs only work with the field selected\n    this.elm.focus();\n    this.elm.setRangeText(text);\n    this.value = this.elm.value;\n    this.position();\n    return this;\n  }\n\n  getSelectedValue(start, end) {\n    var {\n      selectionStart,\n      selectionEnd\n    } = this.elm;\n    return this.value.slice(typeof start === 'number' && !isNaN(start) ? start : selectionStart, typeof end === 'number' && !isNaN(end) ? start : selectionEnd);\n  }\n\n  getLineStartNumber() {\n    var start = this.start;\n\n    while (start > 0) {\n      start--;\n\n      if (this.value.charAt(start) === '\\n') {\n        start++;\n        break;\n      }\n    }\n\n    return start;\n  }\n  /** Indent on new lines */\n\n\n  getIndentText() {\n    var start = this.getLineStartNumber();\n    var str = this.getSelectedValue(start);\n    var indent = '';\n    str.replace(/(^(\\s)+)/, (str, old) => indent = old);\n    return indent;\n  }\n\n  lineStarInstert(text) {\n    if (text) {\n      var oldStart = this.start;\n      var start = this.getLineStartNumber();\n      var str = this.getSelectedValue(start);\n      this.position(start, this.end).insertText(str.split('\\n').map(txt => text + txt).join('\\n')).position(oldStart + text.length, this.end);\n    }\n\n    return this;\n  }\n\n  lineStarRemove(text) {\n    if (text) {\n      var oldStart = this.start;\n      var start = this.getLineStartNumber();\n      var str = this.getSelectedValue(start);\n      var reg = new RegExp(\"^\" + text, 'g');\n      var newStart = oldStart - text.length;\n\n      if (!reg.test(str)) {\n        newStart = oldStart;\n      }\n\n      this.position(start, this.end).insertText(str.split('\\n').map(txt => txt.replace(reg, '')).join('\\n')).position(newStart, this.end);\n    }\n  }\n  /** Notify any possible listeners of the change */\n\n\n  notifyChange() {\n    var event = new Event('input', {\n      bubbles: true,\n      cancelable: false\n    });\n    this.elm.dispatchEvent(event);\n  }\n\n}","map":{"version":3,"sources":["../src/SelectionText.ts"],"names":["elm","start","end","value","constructor","selectionEnd","position","isNaN","insertText","getSelectedValue","getLineStartNumber","getIndentText","str","indent","lineStarInstert","oldStart","txt","text","lineStarRemove","reg","newStart","notifyChange","event","bubbles","cancelable"],"mappings":"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","sourcesContent":["export class SelectionText {\n  elm: HTMLTextAreaElement;\n  start: number;\n  end: number;\n  value: string;\n  constructor(elm: HTMLTextAreaElement) {\n    const { selectionStart, selectionEnd } = elm;\n    this.elm = elm;\n    this.start = selectionStart;\n    this.end = selectionEnd;\n    this.value = this.elm.value;\n  }\n  position(start?: number, end?: number) {\n    const { selectionStart, selectionEnd } = this.elm;\n    this.start = typeof start === 'number' && !isNaN(start) ? start : selectionStart;\n    this.end = typeof end === 'number' && !isNaN(end) ? end : selectionEnd;\n    this.elm.selectionStart = this.start;\n    this.elm.selectionEnd = this.end;\n    return this;\n  }\n  insertText(text: string) {\n    // Most of the used APIs only work with the field selected\n    this.elm.focus();\n    this.elm.setRangeText(text);\n    this.value = this.elm.value;\n    this.position();\n    return this;\n  }\n  getSelectedValue(start?: number, end?: number) {\n    const { selectionStart, selectionEnd } = this.elm;\n    return this.value.slice(\n      typeof start === 'number' && !isNaN(start) ? start : selectionStart,\n      typeof end === 'number' && !isNaN(end) ? start : selectionEnd,\n    );\n  }\n  getLineStartNumber() {\n    let start = this.start;\n    while (start > 0) {\n      start--;\n      if (this.value.charAt(start) === '\\n') {\n        start++;\n        break;\n      }\n    }\n    return start;\n  }\n  /** Indent on new lines */\n  getIndentText() {\n    const start = this.getLineStartNumber();\n    const str = this.getSelectedValue(start);\n    let indent = '';\n    str.replace(/(^(\\s)+)/, (str, old) => (indent = old));\n    return indent;\n  }\n  lineStarInstert(text: string) {\n    if (text) {\n      const oldStart = this.start;\n      const start = this.getLineStartNumber();\n      const str = this.getSelectedValue(start);\n      this.position(start, this.end)\n        .insertText(\n          str\n            .split('\\n')\n            .map((txt) => text + txt)\n            .join('\\n'),\n        )\n        .position(oldStart + text.length, this.end);\n    }\n    return this;\n  }\n  lineStarRemove(text: string) {\n    if (text) {\n      const oldStart = this.start;\n      const start = this.getLineStartNumber();\n      const str = this.getSelectedValue(start);\n      const reg = new RegExp(`^${text}`, 'g');\n      let newStart = oldStart - text.length;\n      if (!reg.test(str)) {\n        newStart = oldStart;\n      }\n      this.position(start, this.end)\n        .insertText(\n          str\n            .split('\\n')\n            .map((txt) => txt.replace(reg, ''))\n            .join('\\n'),\n        )\n        .position(newStart, this.end);\n    }\n  }\n  /** Notify any possible listeners of the change */\n  notifyChange() {\n    const event = new Event('input', { bubbles: true, cancelable: false });\n    this.elm.dispatchEvent(event);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}