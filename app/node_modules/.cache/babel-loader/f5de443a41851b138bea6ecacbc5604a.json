{"ast":null,"code":"'use strict';\n\nmodule.exports = fencedCode;\nvar lineFeed = '\\n';\nvar tab = '\\t';\nvar space = ' ';\nvar tilde = '~';\nvar graveAccent = '`';\nvar minFenceCount = 3;\nvar tabSize = 4;\n\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var gfm = self.options.gfm;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var flag;\n  var lang;\n  var meta;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var indent;\n  var now;\n\n  if (!gfm) {\n    return;\n  } // Eat initial spacing.\n\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== space && character !== tab) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  indent = index; // Eat the fence.\n\n  character = value.charAt(index);\n\n  if (character !== tilde && character !== graveAccent) {\n    return;\n  }\n\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      break;\n    }\n\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n\n  if (fenceCount < minFenceCount) {\n    return;\n  } // Eat spacing before flag.\n\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== space && character !== tab) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  } // Eat flag.\n\n\n  flag = '';\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === lineFeed || marker === graveAccent && character === marker) {\n      break;\n    }\n\n    if (character === space || character === tab) {\n      queue += character;\n    } else {\n      flag += queue + character;\n      queue = '';\n    }\n\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character && character !== lineFeed) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += flag;\n  flag = self.decode.raw(self.unescape(flag), now);\n\n  if (queue) {\n    subvalue += queue;\n  }\n\n  queue = '';\n  closing = '';\n  exdentedClosing = '';\n  content = '';\n  exdentedContent = '';\n  var skip = true; // Eat content.\n\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = '';\n    exdentedClosing = '';\n\n    if (character !== lineFeed) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    } // The first line feed is ignored. Others aren’t.\n\n\n    if (skip) {\n      subvalue += character;\n      skip = false;\n    } else {\n      closing += character;\n      exdentedClosing += character;\n    }\n\n    queue = '';\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== space) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue.slice(indent);\n\n    if (queue.length >= tabSize) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue;\n\n    if (queue.length < fenceCount) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== space && character !== tab) {\n        break;\n      }\n\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n\n    if (!character || character === lineFeed) {\n      break;\n    }\n  }\n\n  subvalue += content + closing; // Get lang and meta from the flag.\n\n  index = -1;\n  length = flag.length;\n\n  while (++index < length) {\n    character = flag.charAt(index);\n\n    if (character === space || character === tab) {\n      if (!lang) {\n        lang = flag.slice(0, index);\n      }\n    } else if (lang) {\n      meta = flag.slice(index);\n      break;\n    }\n  }\n\n  return eat(subvalue)({\n    type: 'code',\n    lang: lang || flag || null,\n    meta: meta || null,\n    value: exdentedContent\n  });\n}","map":{"version":3,"names":["module","exports","fencedCode","lineFeed","tab","space","tilde","graveAccent","minFenceCount","tabSize","eat","value","silent","self","gfm","options","length","index","subvalue","fenceCount","marker","character","flag","lang","meta","queue","content","exdentedContent","closing","exdentedClosing","indent","now","charAt","column","offset","decode","raw","unescape","skip","slice","type"],"sources":["/Users/The5AMDev/web3/gif-portal-starter/node_modules/remark-parse/lib/tokenize/code-fenced.js"],"sourcesContent":["'use strict'\n\nmodule.exports = fencedCode\n\nvar lineFeed = '\\n'\nvar tab = '\\t'\nvar space = ' '\nvar tilde = '~'\nvar graveAccent = '`'\n\nvar minFenceCount = 3\nvar tabSize = 4\n\nfunction fencedCode(eat, value, silent) {\n  var self = this\n  var gfm = self.options.gfm\n  var length = value.length + 1\n  var index = 0\n  var subvalue = ''\n  var fenceCount\n  var marker\n  var character\n  var flag\n  var lang\n  var meta\n  var queue\n  var content\n  var exdentedContent\n  var closing\n  var exdentedClosing\n  var indent\n  var now\n\n  if (!gfm) {\n    return\n  }\n\n  // Eat initial spacing.\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== space && character !== tab) {\n      break\n    }\n\n    subvalue += character\n    index++\n  }\n\n  indent = index\n\n  // Eat the fence.\n  character = value.charAt(index)\n\n  if (character !== tilde && character !== graveAccent) {\n    return\n  }\n\n  index++\n  marker = character\n  fenceCount = 1\n  subvalue += character\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== marker) {\n      break\n    }\n\n    subvalue += character\n    fenceCount++\n    index++\n  }\n\n  if (fenceCount < minFenceCount) {\n    return\n  }\n\n  // Eat spacing before flag.\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== space && character !== tab) {\n      break\n    }\n\n    subvalue += character\n    index++\n  }\n\n  // Eat flag.\n  flag = ''\n  queue = ''\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (\n      character === lineFeed ||\n      (marker === graveAccent && character === marker)\n    ) {\n      break\n    }\n\n    if (character === space || character === tab) {\n      queue += character\n    } else {\n      flag += queue + character\n      queue = ''\n    }\n\n    index++\n  }\n\n  character = value.charAt(index)\n\n  if (character && character !== lineFeed) {\n    return\n  }\n\n  if (silent) {\n    return true\n  }\n\n  now = eat.now()\n  now.column += subvalue.length\n  now.offset += subvalue.length\n\n  subvalue += flag\n  flag = self.decode.raw(self.unescape(flag), now)\n\n  if (queue) {\n    subvalue += queue\n  }\n\n  queue = ''\n  closing = ''\n  exdentedClosing = ''\n  content = ''\n  exdentedContent = ''\n  var skip = true\n\n  // Eat content.\n  while (index < length) {\n    character = value.charAt(index)\n    content += closing\n    exdentedContent += exdentedClosing\n    closing = ''\n    exdentedClosing = ''\n\n    if (character !== lineFeed) {\n      content += character\n      exdentedClosing += character\n      index++\n      continue\n    }\n\n    // The first line feed is ignored. Others aren’t.\n    if (skip) {\n      subvalue += character\n      skip = false\n    } else {\n      closing += character\n      exdentedClosing += character\n    }\n\n    queue = ''\n    index++\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character !== space) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n\n    closing += queue\n    exdentedClosing += queue.slice(indent)\n\n    if (queue.length >= tabSize) {\n      continue\n    }\n\n    queue = ''\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character !== marker) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n\n    closing += queue\n    exdentedClosing += queue\n\n    if (queue.length < fenceCount) {\n      continue\n    }\n\n    queue = ''\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character !== space && character !== tab) {\n        break\n      }\n\n      closing += character\n      exdentedClosing += character\n      index++\n    }\n\n    if (!character || character === lineFeed) {\n      break\n    }\n  }\n\n  subvalue += content + closing\n\n  // Get lang and meta from the flag.\n  index = -1\n  length = flag.length\n\n  while (++index < length) {\n    character = flag.charAt(index)\n\n    if (character === space || character === tab) {\n      if (!lang) {\n        lang = flag.slice(0, index)\n      }\n    } else if (lang) {\n      meta = flag.slice(index)\n      break\n    }\n  }\n\n  return eat(subvalue)({\n    type: 'code',\n    lang: lang || flag || null,\n    meta: meta || null,\n    value: exdentedContent\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}