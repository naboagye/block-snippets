{"ast":null,"code":"import { visit as e } from \"unist-util-visit\";\nimport { toString as t } from \"hast-util-to-string\";\nimport { filter as r } from \"unist-util-filter\";\nimport n from \"parse-numeric-range\";\nimport { refractor as i } from \"refractor/lib/common.js\";\nimport { refractor as o } from \"refractor/lib/all.js\";\n\nfunction a() {\n  a = function (e, t) {\n    return new r(e, void 0, t);\n  };\n\n  var e = RegExp.prototype,\n      t = new WeakMap();\n\n  function r(e, n, i) {\n    var o = new RegExp(e, n);\n    return t.set(o, i || t.get(e)), l(o, r.prototype);\n  }\n\n  function n(e, r) {\n    var n = t.get(r);\n    return Object.keys(n).reduce(function (t, r) {\n      return t[r] = e[n[r]], t;\n    }, Object.create(null));\n  }\n\n  return s(r, RegExp), r.prototype.exec = function (t) {\n    var r = e.exec.call(this, t);\n    return r && (r.groups = n(r, this)), r;\n  }, r.prototype[Symbol.replace] = function (r, i) {\n    if (\"string\" == typeof i) {\n      var o = t.get(this);\n      return e[Symbol.replace].call(this, r, i.replace(/\\$<([^>]+)>/g, function (e, t) {\n        return \"$\" + o[t];\n      }));\n    }\n\n    if (\"function\" == typeof i) {\n      var a = this;\n      return e[Symbol.replace].call(this, r, function () {\n        var e = arguments;\n        return \"object\" != typeof e[e.length - 1] && (e = [].slice.call(e)).push(n(e, a)), i.apply(this, e);\n      });\n    }\n\n    return e[Symbol.replace].call(this, r, i);\n  }, a.apply(this, arguments);\n}\n\nfunction s(e, t) {\n  if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n  e.prototype = Object.create(t && t.prototype, {\n    constructor: {\n      value: e,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), t && l(e, t);\n}\n\nfunction l(e, t) {\n  return l = Object.setPrototypeOf || function (e, t) {\n    return e.__proto__ = t, e;\n  }, l(e, t);\n}\n\nfunction u(e, t) {\n  (null == t || t > e.length) && (t = e.length);\n\n  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];\n\n  return n;\n}\n\nfunction c(e, t) {\n  var r = \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (r) return (r = r.call(e)).next.bind(r);\n\n  if (Array.isArray(e) || (r = function (e, t) {\n    if (e) {\n      if (\"string\" == typeof e) return u(e, t);\n      var r = Object.prototype.toString.call(e).slice(8, -1);\n      return \"Object\" === r && e.constructor && (r = e.constructor.name), \"Map\" === r || \"Set\" === r ? Array.from(e) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? u(e, t) : void 0;\n    }\n  }(e)) || t && e && \"number\" == typeof e.length) {\n    r && (e = r);\n    var n = 0;\n    return function () {\n      return n >= e.length ? {\n        done: !0\n      } : {\n        done: !1,\n        value: e[n++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar p = function e(t) {\n  return t.reduce(function (t, r) {\n    if (\"text\" === r.type) {\n      if (-1 === r.value.indexOf(\"\\n\")) return t.push(r), t;\n\n      for (var n, i = r.value.split(\"\\n\"), o = c(i.entries()); !(n = o()).done;) {\n        var a = n.value,\n            s = a[0],\n            l = a[1];\n        t.push({\n          type: \"text\",\n          value: s === i.length - 1 ? l : l + \"\\n\",\n          position: {\n            start: {\n              line: r.position.start.line + s\n            },\n            end: {\n              line: r.position.start.line + s\n            }\n          }\n        });\n      }\n\n      return t;\n    }\n\n    return Object.prototype.hasOwnProperty.call(r, \"children\") ? (r.children = e(r.children), t.push(r), t) : (t.push(r), t);\n  }, []);\n},\n    f = function (i) {\n  return function (o) {\n    return void 0 === o && (o = {}), function (t) {\n      e(t, \"element\", s);\n    };\n\n    function s(e, s, l) {\n      if (l && \"pre\" === l.tagName && \"code\" === e.tagName) {\n        var u = e.data && e.data.meta ? e.data.meta : \"\";\n        e.properties.className ? \"boolean\" == typeof e.properties.className ? e.properties.className = [] : Array.isArray(e.properties.className) || (e.properties.className = [e.properties.className]) : e.properties.className = [], e.properties.className.push(\"code-highlight\");\n\n        var f,\n            h = function (e) {\n          for (var t, r = c(e.properties.className); !(t = r()).done;) {\n            var n = t.value;\n            if (\"language-\" === n.slice(0, 9)) return n.slice(9).toLowerCase();\n          }\n\n          return null;\n        }(e);\n\n        if (h) try {\n          f = i.highlight(t(e), h), l.properties.className = (l.properties.className || []).concat(\"language-\" + h);\n        } catch (t) {\n          if (!o.ignoreMissing || !/Unknown language/.test(t.message)) throw t;\n          f = e;\n        } else f = e;\n        var m,\n            d = (m = 1, function e(t) {\n          return t.reduce(function (t, r) {\n            if (\"text\" === r.type) {\n              var n = (r.value.match(/\\n/g) || \"\").length;\n              return r.position = {\n                start: {\n                  line: m,\n                  column: 0\n                },\n                end: {\n                  line: m + n,\n                  column: 0\n                }\n              }, m += n, t.push(r), t;\n            }\n\n            if (Object.prototype.hasOwnProperty.call(r, \"children\")) {\n              var i = m;\n              return r.children = e(r.children), t.push(r), r.position = {\n                start: {\n                  line: i,\n                  column: 0\n                },\n                end: {\n                  line: m,\n                  column: 0\n                }\n              }, t;\n            }\n\n            return t.push(r), t;\n          }, []);\n        })(f.children);\n        f.children = p(d), f.children.length > 0 && (f.position = {\n          start: {\n            line: f.children[0].position.start.line,\n            column: 0\n          },\n          end: {\n            line: f.children[f.children.length - 1].position.end.line,\n            column: 0\n          }\n        });\n\n        for (var g, y, v = function (e) {\n          var t = /{([\\d,-]+)}/,\n              r = e.split(\",\").map(function (e) {\n            return e.trim();\n          }).join();\n\n          if (t.test(r)) {\n            var i = t.exec(r)[1],\n                o = n(i);\n            return function (e) {\n              return o.includes(e + 1);\n            };\n          }\n\n          return function () {\n            return !1;\n          };\n        }(u), b = function (e) {\n          var t = /*#__PURE__*/a(/showLineNumbers=([0-9]+)/i, {\n            lines: 1\n          });\n\n          if (t.test(e)) {\n            var r = t.exec(e);\n            return Number(r.groups.lines);\n          }\n\n          return 1;\n        }(u), N = (\"\" === (g = t(e).split(/\\n/))[g.length - 1].trim() && g.pop(), g.map(function (e) {\n          return {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {\n              className: [\"code-line\"]\n            },\n            children: [{\n              type: \"text\",\n              value: e\n            }]\n          };\n        })), w = function () {\n          var e = y.value,\n              n = e[0],\n              i = e[1];\n          (u.toLowerCase().includes(\"showLineNumbers\".toLowerCase()) || o.showLineNumbers) && (i.properties.line = [(n + b).toString()], i.properties.className.push(\"line-number\")), v(n) && i.properties.className.push(\"highlight-line\"), \"diff\" === h && \"-\" === t(i).substring(0, 1) ? i.properties.className.push(\"deleted\") : \"diff\" === h && \"+\" === t(i).substring(0, 1) && i.properties.className.push(\"inserted\");\n          var a = r(f, function (e) {\n            return e.position.start.line <= n + 1 && e.position.end.line >= n + 1;\n          });\n          i.children = a.children;\n        }, x = c(N.entries()); !(y = x()).done;) w();\n\n        e.children = N;\n      }\n    }\n  };\n},\n    h = f(i),\n    m = f(o);\n\nexport { m as default, h as rehypePrismCommon, f as rehypePrismGenerator };","map":{"version":3,"sources":["../src/generator.js","../src/common.js","../src/all.js"],"names":["node","properties","className","classListItem","slice","toLowerCase","meta","RE","parsedMeta","split","map","str","trim","join","test","strlineNumbers","exec","lineNumbers","rangeParser","index","includes","groups","lines","Number","textArray","length","pop","line","type","tagName","children","value","startLineNum","addNodePosition","ast","reduce","result","numLines","match","position","start","column","end","push","Object","prototype","hasOwnProperty","call","initialLineNum","splitTextByLine","indexOf","i","entries","rehypePrismGenerator","refractor","options","tree","visit","visitor","parent","data","Array","isArray","lang","getLanguage","refractorRoot","highlight","toString","concat","err","ignoreMissing","message","nodeWithPosition","shouldHighlightLine","calculateLinesToHighlight","startingLineNumber","calculateStartingLine","codeLineArray","showLineNumbers","substring","treeExtract","filter","rehypePrismCommon","refractorCommon","rehypePrismAll","refractorAll"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef Options options\n *   Configuration.\n * @property {boolean} [showLineNumbers]\n *   Set `showLineNumbers` to `true` to always display line number\n * @property {boolean} [ignoreMissing]\n *   Set `ignoreMissing` to `true` to ignore unsupported languages and line highlighting when no language is specified\n */\n\nimport { visit } from 'unist-util-visit'\nimport { toString } from 'hast-util-to-string'\nimport { filter } from 'unist-util-filter'\nimport rangeParser from 'parse-numeric-range'\n\n/**\n * @param {Element} node\n * @return {string|null}\n */\nconst getLanguage = (node) => {\n  const className = node.properties.className\n  //@ts-ignore\n  for (const classListItem of className) {\n    if (classListItem.slice(0, 9) === 'language-') {\n      return classListItem.slice(9).toLowerCase()\n    }\n  }\n  return null\n}\n\n/**\n * Create a closure that determines if we have to highlight the given index\n *\n * @param {string} meta\n * @return { (index:number) => boolean }\n */\nconst calculateLinesToHighlight = (meta) => {\n  const RE = /{([\\d,-]+)}/\n  // Remove space between {} e.g. {1, 3}\n  const parsedMeta = meta\n    .split(',')\n    .map((str) => str.trim())\n    .join()\n  if (RE.test(parsedMeta)) {\n    const strlineNumbers = RE.exec(parsedMeta)[1]\n    const lineNumbers = rangeParser(strlineNumbers)\n    return (index) => lineNumbers.includes(index + 1)\n  } else {\n    return () => false\n  }\n}\n\n/**\n * Check if we want to start the line numbering from a given number or 1\n * showLineNumbers=5, will start the numbering from 5\n * @param {string} meta\n * @returns {number}\n */\nconst calculateStartingLine = (meta) => {\n  const RE = /showLineNumbers=(?<lines>\\d+)/i\n  // pick the line number after = using a named capturing group\n  if (RE.test(meta)) {\n    const {\n      groups: { lines },\n    } = RE.exec(meta)\n    return Number(lines)\n  }\n  return 1\n}\n\n/**\n * Split line to div node with className `code-line`\n *\n * @param {string} text\n * @return {Element[]}\n */\nconst splitLine = (text) => {\n  // Xdm Markdown parses every code line with \\n\n  const textArray = text.split(/\\n/)\n\n  // Remove last line \\n which results in empty array\n  if (textArray[textArray.length - 1].trim() === '') {\n    textArray.pop()\n  }\n\n  // Empty array are actually line segments so we convert them back to newlines\n  return textArray.map((line) => {\n    return {\n      type: 'element',\n      tagName: 'span',\n      properties: { className: ['code-line'] },\n      children: [{ type: 'text', value: line }],\n    }\n  })\n}\n\n/**\n * Add a node start and end line position information for each text node\n *\n * @return { (ast:Element['children']) => Element['children'] }\n *\n */\nconst addNodePositionClosure = () => {\n  let startLineNum = 1\n  /**\n   * @param {Element['children']} ast\n   * @return {Element['children']}\n   */\n  const addNodePosition = (ast) => {\n    // @ts-ignore\n    return ast.reduce((result, node) => {\n      if (node.type === 'text') {\n        const value = /** @type {string} */ (node.value)\n        const numLines = (value.match(/\\n/g) || '').length\n        node.position = {\n          // column: 0 is to make the ts compiler happy but we do not use this field\n          start: { line: startLineNum, column: 0 },\n          end: { line: startLineNum + numLines, column: 0 },\n        }\n        startLineNum = startLineNum + numLines\n        result.push(node)\n        return result\n      }\n\n      if (Object.prototype.hasOwnProperty.call(node, 'children')) {\n        const initialLineNum = startLineNum\n        // @ts-ignore\n        node.children = addNodePosition(node.children, startLineNum)\n        result.push(node)\n        node.position = {\n          start: { line: initialLineNum, column: 0 },\n          end: { line: startLineNum, column: 0 },\n        }\n        return result\n      }\n\n      result.push(node)\n      return result\n    }, [])\n  }\n  return addNodePosition\n}\n\n/**\n * Split multiline text nodes into individual nodes with positioning\n *\n * @param {Element['children']} ast\n * @return {Element['children']}\n */\nconst splitTextByLine = (ast) => {\n  //@ts-ignore\n  return ast.reduce((result, node) => {\n    if (node.type === 'text') {\n      if (node.value.indexOf('\\n') === -1) {\n        result.push(node)\n        return result\n      }\n\n      const lines = node.value.split('\\n')\n      for (const [i, line] of lines.entries()) {\n        result.push({\n          type: 'text',\n          value: i === lines.length - 1 ? line : line + '\\n',\n          position: {\n            start: { line: node.position.start.line + i },\n            end: { line: node.position.start.line + i },\n          },\n        })\n      }\n\n      return result\n    }\n\n    if (Object.prototype.hasOwnProperty.call(node, 'children')) {\n      // @ts-ignore\n      node.children = splitTextByLine(node.children)\n      result.push(node)\n      return result\n    }\n\n    result.push(node)\n    return result\n  }, [])\n}\n\n/**\n * Rehype prism plugin generator that highlights code blocks with refractor (prismjs)\n *\n * Pass in your own refractor object with the required languages registered:\n * https://github.com/wooorm/refractor#refractorregistersyntax\n *\n * @param {import('refractor/lib/core').Refractor} refractor\n * @return {import('unified').Plugin<[Options?], Root>}\n */\nconst rehypePrismGenerator = (refractor) => {\n  return (options = {}) => {\n    return (tree) => {\n      visit(tree, 'element', visitor)\n    }\n\n    /**\n     * @param {Element} node\n     * @param {number} index\n     * @param {Element} parent\n     */\n    function visitor(node, index, parent) {\n      if (!parent || parent.tagName !== 'pre' || node.tagName !== 'code') {\n        return\n      }\n\n      let meta = node.data && node.data.meta ? /** @type {string} */ (node.data.meta) : ''\n      // Coerce className to array\n      if (node.properties.className) {\n        if (typeof node.properties.className === 'boolean') {\n          node.properties.className = []\n        } else if (!Array.isArray(node.properties.className)) {\n          node.properties.className = [node.properties.className]\n        }\n      } else {\n        node.properties.className = []\n      }\n      node.properties.className.push('code-highlight')\n      const lang = getLanguage(node)\n\n      /** @type {Element} */\n      let refractorRoot\n      let langError = false\n\n      // Syntax highlight\n      if (lang) {\n        try {\n          // @ts-ignore\n          refractorRoot = refractor.highlight(toString(node), lang)\n          // @ts-ignore className is already an array\n          parent.properties.className = (parent.properties.className || []).concat(\n            'language-' + lang\n          )\n        } catch (err) {\n          if (options.ignoreMissing && /Unknown language/.test(err.message)) {\n            langError = true\n            refractorRoot = node\n          } else {\n            throw err\n          }\n        }\n      } else {\n        refractorRoot = node\n      }\n\n      const nodeWithPosition = addNodePositionClosure()(refractorRoot.children)\n      refractorRoot.children = splitTextByLine(nodeWithPosition)\n\n      if (refractorRoot.children.length > 0) {\n        refractorRoot.position = {\n          start: { line: refractorRoot.children[0].position.start.line, column: 0 },\n          end: {\n            line: refractorRoot.children[refractorRoot.children.length - 1].position.end.line,\n            column: 0,\n          },\n        }\n      }\n      const shouldHighlightLine = calculateLinesToHighlight(meta)\n      const startingLineNumber = calculateStartingLine(meta)\n      const codeLineArray = splitLine(toString(node))\n\n      for (const [i, line] of codeLineArray.entries()) {\n        // Code lines\n        if (\n          meta.toLowerCase().includes('showLineNumbers'.toLowerCase()) ||\n          options.showLineNumbers\n        ) {\n          line.properties.line = [(i + startingLineNumber).toString()]\n          // @ts-ignore\n          line.properties.className.push('line-number')\n        }\n\n        // Line highlight\n        if (shouldHighlightLine(i)) {\n          // @ts-ignore\n          line.properties.className.push('highlight-line')\n        }\n\n        if (lang === 'diff' && toString(line).substring(0, 1) === '-') {\n          // @ts-ignore\n          line.properties.className.push('deleted')\n        } else if (lang === 'diff' && toString(line).substring(0, 1) === '+') {\n          // @ts-ignore\n          line.properties.className.push('inserted')\n        }\n\n        // Syntax highlight\n        const treeExtract = filter(\n          refractorRoot,\n          (node) => node.position.start.line <= i + 1 && node.position.end.line >= i + 1\n        )\n        line.children = treeExtract.children\n      }\n\n      node.children = codeLineArray\n    }\n  }\n}\n\nexport default rehypePrismGenerator\n","import { refractor as refractorCommon } from 'refractor/lib/common.js'\nimport rehypePrismGenerator from './generator.js'\n\n/**\n * Rehype prism plugin that highlights code blocks with refractor (prismjs)\n * Supported languages: https://github.com/wooorm/refractor#data\n *\n * Consider using rehypePrismGenerator to generate a plugin\n * that supports your required languages.\n */\nconst rehypePrismCommon = rehypePrismGenerator(refractorCommon)\n\nexport default rehypePrismCommon\n","import { refractor as refractorAll } from 'refractor/lib/all.js'\nimport rehypePrismGenerator from './generator.js'\n\n/**\n * Rehype prism plugin that highlights code blocks with refractor (prismjs)\n * This supports all the languages and should be used on the server side.\n *\n * Consider using rehypePrismCommon or rehypePrismGenerator to generate a plugin\n * that supports your required languages.\n */\nconst rehypePrismAll = rehypePrismGenerator(refractorAll)\n\nexport default rehypePrismAll\n"]},"metadata":{},"sourceType":"module"}